# 程序与进程

- 程序是一系列指令的有序集合，其本身没有任何运行的含义，是一个静态的概念。进程是程序在处理机上的一次执行过程，是一个动态的概念。

- 程序可以作为一种软件资料长期存在，进程是有一定生命期的。程序其实可以可看作一个菜谱，而进程则是按照菜谱进行烹调的过程。

- 对应关系：一个程序运行后可以产生多个进程，一个进程可以调用多个程序。

- 组成不同：进程是由程序块、数据块和进程控制块三部分组成的。


# 进程和线程

- 进程是资源分配最小单位，线程是任务调度和执行的最小单位。

- 创建一个线程比创建进程开销要小，切换线程比切换进程花费要少，可频繁切换。

- 每个进程都有独立的地址空间，来维护代码段、堆栈段和数据段，而线程没有独立的地址空间，使用相同地址空间共享数据，但有独立的运行栈和程序计数器（PC）。

- 多进程程序更安全健壮，一个进程死掉不会对另一个进程造成影响（有独立的地址空间），多线程程序更不易维护，一个线程死掉，整个进程就死掉了。

- 一个进程至少包含一个线程，如果一个进程内有多个线程，则在多核CPU上而是多条线程共同执行完成任务，线程是进程的一部分，所以线程也被常称为轻量级进程。

- 线程之间通信更加方便，通过共享全局变量，静态变量等即可通信，但是需要锁机制、信号量机制、信号机制控制线程间互斥。进程之间的通信复杂一些，可以通过管道（pipe）、命名管道（named pipe/FIFO）、信号量（semophonre）、消息队列（message queue）、信号（sinal）、共享内存（shared memory）、套接字（socket）、全双工管道等来进行通信，共享内存、信号量、消息队列、管道和命名管道只适用于本地进程间通信，套接字和全双工管道可用于远程通信，因此可用于网络编程。


# TCP和UDP

- TCP是面向连接的，发送数据之前需要建立连接（accept->connect->sned->recv），而UDP是无连接的，即发送数据之前不需要建立连接（sendto/recvfrom）。

- TCP是面向字节流，TCP将数据看成一连串无结构的字节流，在缓冲区中拼接分割，无消息边界，而UDP是面向报文的，UDP就原样发送应用层消息，保留消息边界。

- TCP提供可靠服务，通过超时重传、丢弃重复、重新排序、数据校验等机制，保证数据原样有序到达，而UDP并不提供这些机制，只提供校验机制，其他由使用者保证。

- TCP的逻辑通信信道是全双工的可靠信道，只能是点到点的，而UDP则是不可靠信道，支持一对一，一对多，多对一和多对多的交互通信。

- TCP提供拥塞控制，有慢开始、拥塞避免、快重传、快恢复的特点，而UDP不提供，因此网络出现拥塞不会使源主机的发送速率降低（对视频会议等实时应用很有用）。

- TCP提供流量控制，连接的每一方都有固定大小的缓冲空间，使用滑动窗口机制来进行流量控制，而UDP不提供这个机制。

- TCP首部开销较大，最少20字节最多60字节，而UDP的首部开销小，只有8个字节。

- TCP一般用于对可靠性要求较高的协议和应用，如万维网HTTP，电子邮件SMTP，远程终端TELNET，文件传输TFP等，而UDP则常被用于广播和细节控制交给应用的通信，该类应用对网络通讯质量要求不高，但要求网络通讯速度能尽量的快，如远程文件服务NFS，路由选择RIP，域名服务DNS，网络管理SNMP，语音通话，长视频等。


# 面向字节流和面向报文

- 面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。

- 面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。


# TCP三次握手过程

1. A首先向B发起连接，这时TCP头部中的SYN标识位值为1，然后选定一个初始序号seq=x（一般是随机的），消息发送后，A进入SYN_SENT状态，SYN=1的报文段不能携带数据，但要消耗一个序号。

2. B收到A的连接请求后，同意建立连接，向A发送确认数据，这时TCP头部中的SYN和ACK标识位值均为1，确认序号为ack=x+1，然后选定自己的初始序号seq=y（一般是随机的），确认消息发送后，B进入SYN_RCVD状态，与连接消息一样，这条消息也不能携带数据，同时消耗一个序号。

3. A收到B的确认消息后，需要给B回复确认数据，这时TCP头部中的ACK标识位值为1，确认序号是ack=y+1，自己的序号在连接请求的序号上加1，也就是seq=x+1，此时A进入ESTABLISHED状态，当B收到A的确认回复后，B也进入ESTABLISHED状态，至此TCP成功建立连接，A和B之间就可以通过这个连接互相发送数据了。

这样3次握手就完成了，主机A和主机B 就可以传输数据了。

# TCP四次挥手过程

1. A首先向B发送断开连接消息，这时TCP头部中的FIN标识位值为1，序号是seq=m，m为A前面正常发送数据最后一个字节序号加1得到的，消息发送后A进入FNI_WAIT_1状态，FIN=1的报文段不能携带数据，但要消耗一个序号。

2. B收到A的断开连接请求需要发出确认消息，这时TCP头部中的ACK标识位值为1，确认号为ack=m+1，而自己的序号为seq=n,n为B前面正常发送数据最后一个字节序号加1得到的，然后B进入CLOSE_WAIT状态，此时就关闭了A到B的连接，A无法再给B发数据，但是B仍然可以给A发数据（此处存疑），同时B端通知上方应用层，处理完成后被动关闭连接。然后A收到B的确认信息后，就进入了FIN_WAIT_2状态。

3. B端应用层处理完数据后，通知关闭连接，B向A发送关闭连接的消息，这时TCP头部中的FIN和ACK标识位值均为1，确认号ack=m+1，自己的序号为seq=k，（B发出确认消息后有发送了一段数据，此处存疑），消息发送后B进入LAST_ACK状态。

4. A收到B的断开连接的消息后，需要发送确认消息，这是这时TCP头部中的ACK标识位值为1，确认号ack=k+1，序号为m+1（因为A向B发送断开连接的消息时消耗了一个消息号），然后A进入TIME_WAIT状态，若等待时间经过2MSL后，没有收到B的重传请求，则表明B收到了自己的确认，A进入CLOSED状态，B收到A的确认消息后则直接进入CLOSED状态。至此TCP成功断开连接。


# HTTP长连接和短连接

- HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据，相反的就是短连接。其实这里说的长连接和短连接指的就是TCP是不是在传输一次数据就断开。

- HTTP首部的Connection:Keep-alive是HTTP1.0浏览器和服务器的实验性扩展，如果HTTP1.1版本的HTTP请求报文不希望使用长连接，则要在HTTP请求报文首部加上Connection: close。

- 短连接的操作步骤是：建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接，而长连接的操作步骤是：建立连接——数据传输...（保持连接）...数据传输——关闭连接。

- 长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户端适合使用长连接。短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费较多时间和带宽。

# volatile从入门到放弃

- Java的volatile语义是从C/C++的volatile发展而来，并且进行了增强

## C/C++的volatile的语义

- 易变性、确保可见性：即volatile变量的写操作，不会缓存到寄存器中，而是直接回写主存中。而volatile变量的读取，也不会从寄存器中读取，而是从主存中读取，时刻保证取到的值是最新的。

- 不可优化性：即不会对volatile变量进行各种激进的优化，保持变量原有的语义，不能被优化掉。`volatile bool b = false; if (b == true){}`不会优化成`if (false == true){}`。

- 顺序性：编译器会对两个非volatile变量进行乱序优化，C++中编译器对volatile变量与非volatile变量也会进行乱序优化，如果两个变量都声明成了volatile类型，那么生成的汇编代码会阻止这种乱序优化，但是终于生成的指令还是交给cpu来执行的。CPU本身为了提高代码运行的效率，也会对代码的执行顺序进行调整，即CPU级别的乱序优化，如果依赖这种顺序就可能导致程序依赖的逻辑出错，C/C++的volatile对此无能为力。

## Java的volatile的语义

- 前两个特性与C/C++中的含义相同

- 顺序性：针对这个多线程的应用，Java构建了一个happens-before语义，对volatile的语义进行了增强，可以防止volatile变量与普通变量或volatile变量之间的重排序，并且保证cpu执行的时候不会重排。


# C语言32个关键字

一、数据类型关键字（12个）：

(1) char ：声明字符型变量或函数

(2) double ：声明双精度变量或函数

(3) enum ：声明枚举类型

(4) float：声明浮点型变量或函数

(5) int： 声明整型变量或函数

(6) long ：声明长整型变量或函数

(7) short ：声明短整型变量或函数

(8) signed：声明有符号类型变量或函数

(9) struct：声明结构体变量或函数

(10) union：声明共用体（联合）数据类型

(11) unsigned：声明无符号类型变量或函数

(12) void ：声明函数无返回值或无参数，声明无类型指针（基本上就这三个作用）

二、控制语句关键字（12个）：

A循环语句

(1) for：一种循环语句(可意会不可言传）

(2) do ：循环语句的循环体

(3) while ：循环语句的循环条件

(4) break：跳出当前循环

(5) continue：结束当前循环，开始下一轮循环

B条件语句

(1)if: 条件语句

(2)else ：条件语句否定分支（与 if 连用）

(3)goto：无条件跳转语句

C开关语句

(1)switch :用于开关语句

(2)case：开关语句分支

(3)default：开关语句中的“其他”分支

D返回语句

return ：子程序返回语句（可以带参数，也看不带参数）

三、存储类型关键字（4个）

(1)auto ：声明自动变量 一般不使用

(2)extern：声明变量是在其他文件正声明（也可以看做是引用变量）

(3)register：声明积存器变量

(4)static ：声明静态变量

四、其它关键字（4个）：

(1)const ：声明只读变量

(2)sizeof：计算数据类型长度

(3)typedef：用以给数据类型取别名（当然还有其他作用）

(4)volatile：说明变量在程序执行中可被隐含地改变


# 职位

SEO是由英文Search Engine Optimization缩写而来，中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化，比如网站站外推广、网站品牌建设等，使网站满足搜索引擎收录排名需求，在搜索引擎中提高关键词排名，从而吸引精准用户进入网站，获得免费流量，产生直接销售或品牌推广。

HRBP又称为人力资源业务合作伙伴。HRBP(HR BUSINESS PARTNER)实际上就是企业派驻到各个业务或事业部的人力资源管理者，主要协助各业务单元高层及经理在员工发展、人才发掘、能力培养等方面的工作。


# Windows和Linux

- windows文件名不区分大小写，linux文件名区分大小写，这常常是导致问题的根源，比如数据库表的名字。
- 路径分隔符不同，windows上是\，在字符串中会转义，所以常常写成\\，而在linux系统上是/。


# Windows的注册表

注册表的根键共六个，以 `HKEY_` 为前缀，均为大写字母表示，可以通过命令regedit打开后注册表编辑器进行查看和编辑，实际存储在Windows目录下的system.dat和user.dat两个文件中，虽然看起来六个根键处于一种并列的地位，但事实并非如此，更多的数据属于包含关系。

- HKEY_CLASSES_ROOT

 实际上HKEY_CLASSES_ROOT就是HKEY_LOCAL_MACHINE\SOFTWARE\Classes，为了便于用户查看和编辑，系统专门把它作为一个根键，把应用程序与文件扩展名联系起来，由于众多文件类型的存在，导致这个建成为了一个庞大的子键。

- HKEY_CURRENT_USER

 该根键包含本地工作站中存放的当前登录的用户信息，包括用户登录用户名和暂存的密码(此密码在输入时是隐藏的)，用户登录Windows时，其信息从HKEY_USERS中相应的项拷贝到HKEY_CURRENT_USER中。

- HKEY_LOCAL_MACHINE

 该根键下的子关键字包括在system.dat中，包括硬件驱动的配置信息、系统默认软件以及自定义安装软件的配置信息和环境信息等，Windows中的系统环境变量就保存在这个模块。

- HKEY_USERS

 该根键保存了存放在本地计算机口令列表中的用户标识和密码列表。每个用户的预配置信息都存储在HKEY_USERS根键中，是远程计算机中访问的根键之一，数据保存在user.dat中

- HKEY_CURRENT_CONFIG

 该根键存放着定义当前用户桌面配置(如显示器等)的数据，最后使用的文档列表（MRU）和其他有关当前用户的Windows中文版的安装的信息。

- HKEY_DYN_DATA

 目前Win10系统中未发现该键，据说该根键存放了系统在运行时动态数据，此数据在每次显示时都是变化的，因此，此根键下的信息没有放在注册表中。图8显示了HKEY_DYN_DATA根键下的各个子键的情况。

总的来说HKEY_LOCAL_MACHINE存储在system.dat，HKEY_USERS存储在user.dat，剩下的键基本上都是这两个键的分支，为了操作方便单独做出来的映射。


# 版本命名

Redis版本号采用标准惯例：主版本号.副版本号.补丁级别，一个副版本号就标记为一个标准发行版本，例如 1.2，2.0，2.2，2.4，2.6，2.8，奇数的副版本号用来表示非标准版本，例如2.9.x发行版本是Redis 3.0标准版本的非标准发行版本。

# 名词

- KPI：关键绩效指标(KPI：Key Performance Indicator)是通过对组织内部流程的输入端、输出端的关键参数进行设置、取样、计算、分析，衡量流程绩效的一种目标式量化管理指标，是把企业的战略目标分解为可操作的工作目标的工具，是企业绩效管理的基础。

- ROI：Return on Investment，投资回报率（ROI）是指通过投资而应返回的价值，即企业从一项投资活动中得到的经济回报