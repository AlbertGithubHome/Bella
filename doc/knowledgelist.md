# 程序与进程

- 程序是一系列指令的有序集合，其本身没有任何运行的含义，是一个静态的概念。进程是程序在处理机上的一次执行过程，是一个动态的概念。

- 程序可以作为一种软件资料长期存在，进程是有一定生命期的。程序其实可以可看作一个菜谱，而进程则是按照菜谱进行烹调的过程。

- 对应关系：一个程序运行后可以产生多个进程，一个进程可以调用多个程序。

- 组成不同：进程是由程序块、数据块和进程控制块三部分组成的。


# 进程和线程

- 进程是资源分配最小单位，线程是任务调度和执行的最小单位。

- 创建一个线程比创建进程开销要小，切换线程比切换进程花费要少，可频繁切换。

- 每个进程都有独立的地址空间，来维护代码段、堆栈段和数据段，而线程没有独立的地址空间，使用相同地址空间共享数据，但有独立的运行栈和程序计数器（PC）。

- 多进程程序更安全健壮，一个进程死掉不会对另一个进程造成影响（有独立的地址空间），多线程程序更不易维护，一个线程死掉，整个进程就死掉了。

- 一个进程至少包含一个线程，如果一个进程内有多个线程，则在多核CPU上而是多条线程共同执行完成任务，线程是进程的一部分，所以线程也被常称为轻量级进程。

- 线程之间通信更加方便，通过共享全局变量，静态变量等即可通信，但是需要锁机制、信号量机制、信号机制控制线程间互斥。进程之间的通信复杂一些，可以通过管道（pipe）、命名管道（named pipe/FIFO）、信号量（semophonre）、消息队列（message queue）、信号（sinal）、共享内存（shared memory）、套接字（socket）、全双工管道等来进行通信，共享内存、信号量、消息队列、管道和命名管道只适用于本地进程间通信，套接字和全双工管道可用于远程通信，因此可用于网络编程。


# TCP和UDP

- TCP是面向连接的，发送数据之前需要建立连接（accept->connect->sned->recv），而UDP是无连接的，即发送数据之前不需要建立连接（sendto/recvfrom）。

- TCP是面向字节流，TCP将数据看成一连串无结构的字节流，在缓冲区中拼接分割，无消息边界，而UDP是面向报文的，UDP就原样发送应用层消息，保留消息边界。

- TCP提供可靠服务，通过超时重传、丢弃重复、重新排序、数据校验等机制，保证数据原样有序到达，而UDP并不提供这些机制，只提供校验机制，其他由使用者保证。

- TCP的逻辑通信信道是全双工的可靠信道，只能是点到点的，而UDP则是不可靠信道，支持一对一，一对多，多对一和多对多的交互通信。

- TCP提供拥塞控制，有慢开始、拥塞避免、快重传、快恢复的特点，而UDP不提供，因此网络出现拥塞不会使源主机的发送速率降低（对视频会议等实时应用很有用）。

- TCP提供流量控制，连接的每一方都有固定大小的缓冲空间，使用滑动窗口机制来进行流量控制，而UDP不提供这个机制。

- TCP首部开销较大，最少20字节最多60字节，而UDP的首部开销小，只有8个字节。

- TCP一般用于对可靠性要求较高的协议和应用，如万维网HTTP，电子邮件SMTP，远程终端TELNET，文件传输TFP等，而UDP则常被用于广播和细节控制交给应用的通信，该类应用对网络通讯质量要求不高，但要求网络通讯速度能尽量的快，如远程文件服务NFS，路由选择RIP，域名服务DNS，网络管理SNMP，语音通话，长视频等。


# 面向字节流和面向报文

- 面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。

- 面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。


# TCP三次握手过程

1. A首先向B发起连接，这时TCP头部中的SYN标识位值为1，然后选定一个初始序号seq=x（一般是随机的），消息发送后，A进入SYN_SENT状态，SYN=1的报文段不能携带数据，但要消耗一个序号。

2. B收到A的连接请求后，同意建立连接，向A发送确认数据，这时TCP头部中的SYN和ACK标识位值均为1，确认序号为ack=x+1，然后选定自己的初始序号seq=y（一般是随机的），确认消息发送后，B进入SYN_RCVD状态，与连接消息一样，这条消息也不能携带数据，同时消耗一个序号。

3. A收到B的确认消息后，需要给B回复确认数据，这时TCP头部中的ACK标识位值为1，确认序号是ack=y+1，自己的序号在连接请求的序号上加1，也就是seq=x+1，此时A进入ESTABLISHED状态，当B收到A的确认回复后，B也进入ESTABLISHED状态，至此TCP成功建立连接，A和B之间就可以通过这个连接互相发送数据了。

这样3次握手就完成了，主机A和主机B 就可以传输数据了。

# TCP四次挥手过程

1. A首先向B发送断开连接消息，这时TCP头部中的FIN标识位值为1，序号是seq=m，m为A前面正常发送数据最后一个字节序号加1得到的，消息发送后A进入FNI_WAIT_1状态，FIN=1的报文段不能携带数据，但要消耗一个序号。

2. B收到A的断开连接请求需要发出确认消息，这时TCP头部中的ACK标识位值为1，确认号为ack=m+1，而自己的序号为seq=n,n为B前面正常发送数据最后一个字节序号加1得到的，然后B进入CLOSE_WAIT状态，此时就关闭了A到B的连接，A无法再给B发数据，但是B仍然可以给A发数据（此处存疑），同时B端通知上方应用层，处理完成后被动关闭连接。然后A收到B的确认信息后，就进入了FIN_WAIT_2状态。

3. B端应用层处理完数据后，通知关闭连接，B向A发送关闭连接的消息，这时TCP头部中的FIN和ACK标识位值均为1，确认号ack=m+1，自己的序号为seq=k，（B发出确认消息后有发送了一段数据，此处存疑），消息发送后B进入LAST_ACK状态。

4. A收到B的断开连接的消息后，需要发送确认消息，这是这时TCP头部中的ACK标识位值为1，确认号ack=k+1，序号为m+1（因为A向B发送断开连接的消息时消耗了一个消息号），然后A进入TIME_WAIT状态，若等待时间经过2MSL后，没有收到B的重传请求，则表明B收到了自己的确认，A进入CLOSED状态，B收到A的确认消息后则直接进入CLOSED状态。至此TCP成功断开连接。